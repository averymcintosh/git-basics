Github notes:Git is a revision control system, a tool to manage your source code history. GitHub is a hosting service for Git repositories. So they are not the same thing: Git the tool, GitHub the service for projects that uses Git.Version control: tracks changes to projects over time and is more efficient than having many separate folders for each version of your project.There are two types of version control systems (VCS): centralized and distributed. Centralized maintains a central file and makes it so that if one person is working on it then another person can't, so it's not overwritten. Central hub of file (think dropbox). E.g. CVS, subversion.Git is distributed: each person has a mirror, and in this way if any individual mirror goes down, simply cloning a person's file restores it. It's better for not losing data. People can push changes to a different repository, or sync changes across every persons' repositories, when appropriate.GitHub is free for public repositories, and there is a relatively modest pricing scheme for private, invite-only repositories (you get 5 for $7/mo.): https://github.com/pricing In terminal, type man git for the github manual (q to exit), or git help <command name> to get documentation on a particular command.Using the GitHub client (app), I cloned the documents from the repository to my computer.When first starting up, you need to set up your e-mail and username.git config --global user.name “username” (use your github name)git config --global user.email username@host.comgit config --global color.ui true (last one adds colors to terminal)To create a remote repo from local repo, I set up files in a folder called ‘import2,’ then on Github I created an empty repo titled ‘import2’. My local repo has two files.  I then typed: git initgit remote add origin https://github.com/averymcintosh/import2.git, which was taken from the Github website when I initialized my origin repo. git add '*.txt'(this stages the files in my local repo)git commit -m "initial commit" which will commit the staged files, and thengit push -u origin masterAll this is the initial sync of the remote and the local. Push an existing local repo from command line:git remote add origin https://github.com/averymcintosh/import.git git push -u origin masterCreate folder, work on as necessary. When ready to start, type git init(creates a LOCAL git repo)git add <filenames>git commit –m “first commit for <repo name>”\git remote add origin http://<url for repo made on git website>git push -u origin masterWhen you change a file you create a snapshot of the file at that point, called a “commit”.There are three workflow areas:Working directory: this has current state of files based on current commit. Staging area: index of everything that will be contained in the next commit. Once that’s made it’s added to the Git repo.Git repo: where everything is renewed.Each file in your working directory can be in one of two states: tracked or untracked. Tracked files are files that were in the last snapshot, and are either MODIFIED, UNMODIFIED, OR STAGED. The first two are what they sound like, but the third is when files are put in the queue to be updated into the repository. Staged files can be a changed file that can be tested locally without being updated to everyone’s repo. Untracked files are everything else – any files in your working directory that were not in your last snapshot and are not in your staging area. Untracked basically means that Git sees a file you didn’t have in the previous snapshot (commit); Git won’t start including it in your commit snapshots until you explicitly tell it to do so. It does this so you don’t accidentally begin including generated binary files or other files that you did not mean to include. In order to begin tracking a new file, you use the command git add. Use command git add <folder>/* to add all files in a subfolder.When you first clone a repository, all of your files will be tracked and unmodified because you just checked them out and haven’t edited anything. As you edit files, Git sees them as modified, because you’ve changed them since your last commit. You stage these modified files and then commit all your staged changes, and the cycle repeats. In SmartGit application, staging and committing are done in the same step. Normally, if you change a file, you need to stage it before you commit it, even if you’ve previously staged it before. We could add or remove files from the stage before we store them in the repository.Command git status will tell you what’s in your git folder, and git add <filename> will prepare the file for staging. Then you can type git commit which brings you into a VIM text editor, where you type your message about the commit, then type esc :wq to exit. If you then type git status, nothing appears, because there’s nothing in the staging area.You can also type git commit -m “short message” if you don’t want to enter the VIM editor. After a file has been added, type git add <filename> and then type git push origin master, where earlier you typed commands from this instruction: https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/Commands to change file from local to master:•	git status (check it out)•	git add <filename> (prepares a file for staging, to be included later in the next snapshot/commit)•	git commit (enters text editor, hit ecs:wq to exit once message is written, could also write git commit -m “message about changes”)•	git commit -a(commits and stages all tracked files in one operation)•	git add ‘*.txt’     or     git add --all (add multiple files to staging ending in .txt)•	git commit -m ‘add all .txt files’(now commit the changes to all added files)•	git log(gives a record of all comments associated with )•	git remote add origin https://github.com/try-git/try_git.git(adds a remote name and repository URL you can push a local repo to)•	git push -u origin master(publish changes on master branch)(The name of our remote is origin and the default local branch name is master. The -u tells Git to remember the parameters, so that next time we can simply run git push and Git will know what to do.)•	git pull origin master(check for changes on our GitHub repository and pull down any new changes after other people have pushed their changes to the master branch)•	git diff HEAD(checking what is different in the origin from our last commit—perhaps someone added new files, we want to see that)•	git diff --staged (check out what is different between what has been locally staged and the previous snapshot—type q to exit the browser)•	git reset <filename>(unstages file)•	git checkout -- <filename>(change files back to how they were at the last commit)•	git branch <branch name>(make a copy of code, or master branch, to do work on separately for later merging back into the master branch)•	git branch(tells which branches there are, which you’re on)•	git checkout <branchname>(switch branch you’re on)•	git rm ‘*.txt’(removes all files ending in .txt and stages what’s left)•	git commit -m “removed all files”(committing branch changes)•	git checkout master(return to master branch in preparation for merging with your new branch)•	git merge <new branch name>(since we’re on master now, we’re merging the new branch onto the master. Since there were no files the master had that the branch didn’t, there were no conflicts and the merge went through automatically)•	git branch –d <branch name>(remove test branch that was created to cleanup the files, then add it all into the remote repository with git push)From the SmartGit symbol node section:o [>1 master] D|o [origin/master] C|o B|o AThis means that A is a commit, B is a commit, then C is a commit and push to origin. D indicates that master is one change ahead of the master branch, so a change was made and committed, but not pushed to the origin.